---
title: Neo's Fun - ООП за 5 минут
---
# Базовые термины

* Полиморфизм
* Наследование
* Инкапсуляция

Помним всегда что полиморфизм без наследования не возможен (во всяком случае в c++).

## Как ООП за пять минут.

1. У нас есть объекты из одного класса области (например фрукты).
2. У каждого объекта есть имя (или тип) и набор параметров: (апельсин: оранжевый и кислый, помидор: красный и сочный)
3. Для более удобной обработки мы хотим сложить все объекты в один массив (это только один шаблонов использования)

Теперь опишем базовый класс

```
Класс Фруктоовощ:
    имя(): строка, по умолчанию "";
    сорт(): строка, по умолчанию "";
    какого_он_цвета(): строка, по умолчанию "";
    он_кислый(): число, по умолчанию 0; # 0-10
    он_сладкий(): число, по умолчанию 0; # 0-10
    он_горький(): число, по умолчанию 0; # 0-10
    на_складе(): число, по умолчанию 0; # 0-10
    ... и тд.
    скрыть переменную А = 0;
```

Далее опишем несколько классов наследуя их от Фркутоовощ

**класс Мандарин_Морокко**
```
Класс Мандарин_Морокко от Фруктоовощ:
    имя(): вернуть "Мандарин";
    сорт(): вернуть "Морокко";
    какого_он_цвета(): вернуть "оранжевый";
    он_кислый(): вернуть 2;
    он_сладкий(): вернуть А + 8;
    на_складе(): вернуть 10;
```

**класс Мандарин_Китайский**
```
Класс Мандарин_Китайский от Фруктоовощ:
    имя(): вернуть "Мандарин";
    сорт(): вернуть "Китайский";
    какого_он_цвета(): вернуть "оранжевый";
    он_кислый(): вернуть 3;
    он_сладкий(): вернуть 5;
    на_складе(): вернуть 20;
```

**класс Апельсин1**
```
Класс Апельсин1 от Фруктоовощ:
    имя(): вернуть "апельсин";
    сорт(): вернуть "1";
    какого_он_цвета(): вернуть "оранжевый";
    он_кислый(): вернуть 7;
    он_сладкий(): вернуть 3;
    он_горький(): вернуть 1;
    на_складе(): вернуть 5;
```

**класс Помидор**
```
Класс Помидор от Фруктоовощ:
    имя(): вернуть "помидор";
    сорт(): вернуть "ачинский";
    какого_он_цвета(): вернуть "красный";
    он_сладкий(): вернуть 2;
    на_складе(): вернуть 100;
```

Теперь опищем основной алгоритм, например для поиска самого сладкого фрукта:

```
Массив фо[]: Фруктоовощ;
фо[0] = создать Мандарин_Морокко;
фо[1] = создать Мандарин_Китайский;
фо[2] = создать Апельсин1;
фо[3] = создать Помидор;

индекс_самого_сладкого_фрукта = -1
значение_сладости = 0

цикл индекс от 0 до 3:
    если фо[индекс].он_сладкий() больше чем значение_сладости:
        значение_сладости = фо[индекс].он_сладкий()
        индекс_самого_сладкого_фрукта = индекс

если индекс_самого_сладкого_фрукта > 0:
    распечатать фо[индекс_самого_сладкого_фрукта]
```

Теперь где здесь что:

* `Фруктоовощ` - это базовый класс или класс-родитель
* `Мандарин_Морокко`, `Мандарин_Китайский`,...  - это дочерний класс или класс-потомок
* `Класс Помидор от Фруктоовощ` - это и есть наследование то есть у дочернего класса есть все методы что и у родительского
* `он_сладкий(): вернуть А + 8;` - При наследование свойства объекта инкапсулируеются то есть в дочернем объекте есть все такие же свойства. Нуу и нет необходимости определять какие то методы - так как они уже есть (!)
* `имя()`, `сорт()`, `какого_он_цвета()`, ... - это полиморфные методы то есть в дочерних классах их можно переопределить (поменять/подменить реализацию)


В этом примере есть все три основных свойства ООП - полиморфизм, наследование, инкапсуляция.

* полиморфизм - возможность менять реализацию в дочернем классе некоторых методов.
* наследование - возможность наследовать свойства и методы от определенного класса.
* инкапсуляция - перенимание всех свойств родительского класса.

## Далее попробуем соорудить что нить полезное с использвоанием ООП

...